# agent.py

#! Custom TODO notes:
#TODO AD: Add docstring.
#TODO ATH: Add type hint.
#TODO CTH: Check type hint.
#TODO FTH: Fix the hardcoding.
#TODO HPE: Handle possible error.
#TODO AC: Add comment.
#TODO AIC: Add input control.
#TODO ACV: Add constant variable.
#TODO WOO: Work on organising.

#! PW: Possibly wrong.

from typing import Tuple

import numpy as np
import polars as pl
from polars import DataFrame

from dataclasses import dataclass
from numpy.typing import NDArray

from dataclasses import dataclass
from typing import Tuple

# Type alias for clarity
MoveDirection = Tuple[int, int]

@dataclass(frozen=True)
class ConfigAgentManager:
    """
    Configuration for the Agent Manager.
    Variables are grouped logically by function.
    """

    # 1. SIMULATION & MATRIX CONSTANTS
    EMPTY_MATRIX_ID: int = 0
    AGENT_MATRIX_ID: int = 1
    # Order: Up, Right, Down, Left
    MOVEMENT_DIRECTIONS: Tuple[MoveDirection, MoveDirection, MoveDirection, MoveDirection] = (
        (0, -1), (1, 0), (0, 1), (-1, 0)
    )

    # 2. PHYSICAL GENETICS
    MIN_SIZE: int = 1
    MAX_SIZE: int = 3
    MIN_AGE: int = 50
    MAX_AGE: int = 250
    MIN_HEALTH: int = 50
    MAX_HEALTH: int = 250
    MIN_ENERGY: int = 50
    MAX_ENERGY: int = 250
    MIN_TEMP: int = 0
    MAX_TEMP: int = 50
    
    MIN_ENERGY_BURN: float = 0.1
    MAX_ENERGY_BURN: float = 1.0
    MIN_RESISTANCE: float = 0.1
    MAX_RESISTANCE: float = 1.0

    # 3. SURVIVAL GENETICS (Ranges & Chances)
    MIN_CHRONOTYPE: float = 0.1
    MAX_CHRONOTYPE: float = 1.0
    MIN_PLANT_DIGEST: float = 0.1
    MAX_PLANT_DIGEST: float = 1.0
    MIN_MEAT_DIGEST: float = 0.1
    MAX_MEAT_DIGEST: float = 1.0
    
    VENOM_CHANCE: float = 0.1
    MIMICRY_CHANCE: float = 0.1

    # 4. BEHAVIORAL GENETICS (Ranges)
    MIN_KINSHIP: float = 0.1
    MAX_KINSHIP: float = 1.0
    MIN_PARENTAL: float = 0.1
    MAX_PARENTAL: float = 1.0
    MIN_HOSTILITY: float = 0.1
    MAX_HOSTILITY: float = 1.0
    MIN_FIGHT_FLIGHT: float = 0.1
    MAX_FIGHT_FLIGHT: float = 1.0

    # 5. METABOLISM & MULTIPLIERS
    BIRTH_ENERGY_FACTOR: float = 0.5
    METABOLISM_INFECTED_MULT: float = 1.25
    METABOLISM_BLEEDING_MULT: float = 1.25
    METABOLISM_SLEEPING_MULT: float = 0.2
    METABOLISM_PREGNANT_MULT: float = 1.5
    METABOLISM_HIBERNATING_MULT: float = 0.05
    METABOLISM_TEMP_HARSHNESS: float = 0.1

    # 6. COSTS & PENALTIES
    MOVE_ENERGY_COST: int = 5
    DISEASE_HEALTH_COST: int = 5
    BLEEDING_HEALTH_COST: int = 10

    # 7. TIMERS & CAPACITIES
    GESTATION_TIME: int = 250
    MAX_WASTE_CAPACITY: int = 100

    def __post_init__(self) -> None:
        """
        Validates all configuration parameters immediately after initialization.
        Checks match the order of declaration.
        """
        
        # 1. SIMULATION & MATRIX CONSTANTS Validation 
        if not isinstance(self.EMPTY_MATRIX_ID, int) or not isinstance(self.AGENT_MATRIX_ID, int):
            raise TypeError("Matrix IDs must be integers.")
        
        if self.EMPTY_MATRIX_ID == self.AGENT_MATRIX_ID:
            raise ValueError(f"EMPTY_MATRIX_ID and AGENT_MATRIX_ID cannot be the same ({self.EMPTY_MATRIX_ID}).")

        if not isinstance(self.MOVEMENT_DIRECTIONS, tuple):
            raise TypeError("MOVEMENT_DIRECTIONS must be a tuple.")
        if len(self.MOVEMENT_DIRECTIONS) != 4:
            raise ValueError(f"MOVEMENT_DIRECTIONS must have 4 elements, got {len(self.MOVEMENT_DIRECTIONS)}.")
        for d in self.MOVEMENT_DIRECTIONS:
            if not isinstance(d, tuple) or len(d) != 2 or not all(isinstance(x, int) for x in d):
                raise TypeError("Each movement direction must be a tuple of 2 integers (dx, dy).")

        # 2. PHYSICAL GENETICS Validation 
        int_phys_ranges = [
            ("SIZE", self.MIN_SIZE, self.MAX_SIZE),
            ("AGE", self.MIN_AGE, self.MAX_AGE),
            ("HEALTH", self.MIN_HEALTH, self.MAX_HEALTH),
            ("ENERGY", self.MIN_ENERGY, self.MAX_ENERGY),
            ("TEMP", self.MIN_TEMP, self.MAX_TEMP),
        ]
        for name, min_val, max_val in int_phys_ranges:
            if not isinstance(min_val, int) or not isinstance(max_val, int):
                raise TypeError(f"MIN_{name} and MAX_{name} must be integers.")
            if min_val < 0:
                raise ValueError(f"MIN_{name} must be non-negative.")
            if max_val < min_val:
                raise ValueError(f"MAX_{name} ({max_val}) cannot be smaller than MIN_{name} ({min_val}).")

        float_phys_ranges = [
            ("ENERGY_BURN", self.MIN_ENERGY_BURN, self.MAX_ENERGY_BURN),
            ("RESISTANCE", self.MIN_RESISTANCE, self.MAX_RESISTANCE),
        ]
        for name, min_val, max_val in float_phys_ranges:
            if not isinstance(min_val, (float, int)) or not isinstance(max_val, (float, int)):
                raise TypeError(f"MIN_{name} and MAX_{name} must be numbers.")
            if min_val < 0:
                raise ValueError(f"MIN_{name} must be non-negative.")
            if max_val < min_val:
                raise ValueError(f"MAX_{name} ({max_val}) cannot be smaller than MIN_{name} ({min_val}).")

        #  3. SURVIVAL GENETICS Validation 
        float_surv_ranges = [
            ("CHRONOTYPE", self.MIN_CHRONOTYPE, self.MAX_CHRONOTYPE),
            ("PLANT_DIGEST", self.MIN_PLANT_DIGEST, self.MAX_PLANT_DIGEST),
            ("MEAT_DIGEST", self.MIN_MEAT_DIGEST, self.MAX_MEAT_DIGEST),
        ]
        for name, min_val, max_val in float_surv_ranges:
            if not isinstance(min_val, (float, int)) or not isinstance(max_val, (float, int)):
                raise TypeError(f"MIN_{name} and MAX_{name} must be numbers.")
            if min_val < 0:
                raise ValueError(f"MIN_{name} must be non-negative.")
            if max_val < min_val:
                raise ValueError(f"MAX_{name} ({max_val}) cannot be smaller than MIN_{name} ({min_val}).")

        probs = [("VENOM_CHANCE", self.VENOM_CHANCE), ("MIMICRY_CHANCE", self.MIMICRY_CHANCE)]
        for name, val in probs:
            if not isinstance(val, (float, int)):
                raise TypeError(f"{name} must be a number.")
            if not (0.0 <= val <= 1.0):
                raise ValueError(f"{name} must be between 0.0 and 1.0.")

        #  4. BEHAVIORAL GENETICS Validation 
        float_behav_ranges = [
            ("KINSHIP", self.MIN_KINSHIP, self.MAX_KINSHIP),
            ("PARENTAL", self.MIN_PARENTAL, self.MAX_PARENTAL),
            ("HOSTILITY", self.MIN_HOSTILITY, self.MAX_HOSTILITY),
            ("FIGHT_FLIGHT", self.MIN_FIGHT_FLIGHT, self.MAX_FIGHT_FLIGHT),
        ]
        for name, min_val, max_val in float_behav_ranges:
            if not isinstance(min_val, (float, int)) or not isinstance(max_val, (float, int)):
                raise TypeError(f"MIN_{name} and MAX_{name} must be numbers.")
            if min_val < 0:
                raise ValueError(f"MIN_{name} must be non-negative.")
            if max_val < min_val:
                raise ValueError(f"MAX_{name} ({max_val}) cannot be smaller than MIN_{name} ({min_val}).")

        #  5. METABOLISM & MULTIPLIERS Validation 
        multipliers = [
            ("BIRTH_ENERGY_FACTOR", self.BIRTH_ENERGY_FACTOR),
            ("METABOLISM_INFECTED_MULT", self.METABOLISM_INFECTED_MULT),
            ("METABOLISM_BLEEDING_MULT", self.METABOLISM_BLEEDING_MULT),
            ("METABOLISM_SLEEPING_MULT", self.METABOLISM_SLEEPING_MULT),
            ("METABOLISM_PREGNANT_MULT", self.METABOLISM_PREGNANT_MULT),
            ("METABOLISM_HIBERNATING_MULT", self.METABOLISM_HIBERNATING_MULT),
            ("METABOLISM_TEMP_HARSHNESS", self.METABOLISM_TEMP_HARSHNESS),
        ]
        for name, val in multipliers:
            if not isinstance(val, (float, int)):
                raise TypeError(f"{name} must be a number.")
            if val < 0:
                raise ValueError(f"{name} must be non-negative.")

        #  6. COSTS & PENALTIES Validation 
        costs = [
            ("MOVE_ENERGY_COST", self.MOVE_ENERGY_COST),
            ("DISEASE_HEALTH_COST", self.DISEASE_HEALTH_COST),
            ("BLEEDING_HEALTH_COST", self.BLEEDING_HEALTH_COST),
        ]
        for name, val in costs:
            if not isinstance(val, int):
                raise TypeError(f"{name} must be an integer.")
            if val < 0:
                raise ValueError(f"{name} must be non-negative.")

        #  7. TIMERS & CAPACITIES Validation 
        timers = [
            ("GESTATION_TIME", self.GESTATION_TIME),
            ("MAX_WASTE_CAPACITY", self.MAX_WASTE_CAPACITY),
        ]
        for name, val in timers:
            if not isinstance(val, int):
                raise TypeError(f"{name} must be an integer.")
            if val < 0:
                raise ValueError(f"{name} must be non-negative.")

class AgentManager:

    def __init__(
            self,
            config_agent_manager: ConfigAgentManager,
            simulation_size: int
    ) -> None:
        # 1. Defines input parameters.
        self.config_agent_manager: ConfigAgentManager = config_agent_manager
        self.simulation_size: int = simulation_size

        # 2. Creates agent matrices.
        self.agent_matrix: NDArray = np.zeros(
            shape = (self.simulation_size, self.simulation_size),
            dtype = np.uint8
        )

        self.agent_color_matrix: NDArray = np.zeros(
            shape = (self.simulation_size, self.simulation_size, 3),
            dtype = np.uint8
        )

        # 3. Creates a agent DataFrame.
        self.agents_df: DataFrame = self._create_empty_agent_df()

    def _create_empty_agent_df(self) -> DataFrame:   
        agent_df_schema: dict = {
            #TODO WOO
            # Identity Genetics.
            "sex": pl.UInt8, 
            "clan_id": pl.UInt8,

            # Physical Genetics.
            "size": pl.UInt8,
            "max_age": pl.UInt8,
            "max_health": pl.UInt8,
            "max_energy": pl.UInt8,
            "optimal_temperature": pl.UInt8,
            "base_energy_burn_rate": pl.Float32, # Use instead of Float16, since it is not natively supported by many CPUs.
            "total_energy_burn_rate": pl.Float32,
            "resistance": pl.Float32,

            # Survival Genetics.
            "chronotype": pl.Float32,
            "plant_digestion_efficiency": pl.Float32,
            "meat_digestion_efficiency": pl.Float32,
            "has_venom": pl.Boolean, 
            "has_mimicry": pl.Boolean,

            # Behavioral Genetics.
            "kinship_loyalty": pl.Float32,
            "parental_instinct": pl.Float32,
            "hostility": pl.Float32,
            "fight_flight_bias":pl.Float32,

            # Metabolic States.
            "is_infected": pl.Boolean,
            "is_bleeding": pl.Boolean,
            "is_sleeping": pl.Boolean,
            "is_pregnant": pl.Boolean,
            "is_hibernating": pl.Boolean,
            "metabolism_modifier": pl.Float32,
            "health_cost": pl.UInt8,

            # Timers & Counters.
            "hibernation_timer":pl.UInt8,
            "gestation_timer": pl.UInt8,
            "waste_accumulated": pl.UInt8,

            # Positional States.
            "x_pos": pl.UInt8,
            "y_pos": pl.UInt8,
            "new_x_pos": pl.Int8,
            "new_y_pos": pl.Int8,
            "valid_move": pl.Boolean,

            # Vital States.
            "age": pl.UInt8,
            "health": pl.Float32,
            "energy": pl.Float32,
            "effective_resistance": pl.Float32,

            # Derived States.
            "color_r": pl.UInt8,
            "color_g": pl.UInt8,
            "color_b": pl.UInt8,
        }

        return pl.DataFrame(schema=agent_df_schema) # Creates a DataFrame from the schema dictionary.

    def create_agents(
            self,
            count: int
    ) -> None:
        #TODO WOO: The order of the attributes in the dictionary.
        # 1. Creates a random number generator instance.
        rng = np.random.default_rng()

        # 2. Generates all random data in a single dictionary definition.
        agent_data: dict[str, NDArray] = {
            #TODO WOO
            # Identity Genetics.
            "sex": rng.integers(low=0, high=2 + 1, size=count), #TODO ACV
            "clan_id": rng.integers(low=0, high=0 + 1, size=count), #TODO Add Clan ID mechanism.

            # Physical Genetics.
            "size": rng.integers(low=self.config_agent_manager.MIN_SIZE, high=self.config_agent_manager.MAX_SIZE + 1, size=count),
            "max_age": rng.integers(low=self.config_agent_manager.MIN_AGE, high=self.config_agent_manager.MAX_AGE + 1, size=count),
            "max_health": rng.integers(low=self.config_agent_manager.MIN_HEALTH, high=self.config_agent_manager.MAX_HEALTH + 1, size=count),
            "max_energy": rng.integers(low=self.config_agent_manager.MIN_ENERGY, high=self.config_agent_manager.MAX_ENERGY + 1, size=count),
            "optimal_temperature": rng.integers(low=self.config_agent_manager.MIN_TEMP, high=self.config_agent_manager.MAX_TEMP + 1, size=count),
            "base_energy_burn_rate": rng.uniform(low=self.config_agent_manager.MIN_ENERGY_BURN, high=self.config_agent_manager.MAX_ENERGY_BURN + 1, size=count),
            "resistance": rng.uniform(low=self.config_agent_manager.MIN_RESISTANCE, high=self.config_agent_manager.MAX_RESISTANCE + 1, size=count),

            # Survival Genetics.
            "chronotype": rng.uniform(low=self.config_agent_manager.MIN_CHRONOTYPE, high=self.config_agent_manager.MAX_CHRONOTYPE + 1, size=count),
            "plant_digestion_efficiency": rng.uniform(low=self.config_agent_manager.MIN_PLANT_DIGEST, high=self.config_agent_manager.MAX_PLANT_DIGEST + 1, size=count),
            "meat_digestion_efficiency": rng.uniform(low=self.config_agent_manager.MIN_MEAT_DIGEST, high=self.config_agent_manager.MAX_MEAT_DIGEST + 1, size=count),
            "has_venom": rng.uniform(low=0, high=1, size=count) < self.config_agent_manager.VENOM_CHANCE, # Creates a boolean array according to the condition.
            "has_mimicry": rng.uniform(low=0, high=1, size=count) < self.config_agent_manager.MIMICRY_CHANCE,

            # Behavioral Genetics.
            "kinship_loyalty": rng.uniform(low=self.config_agent_manager.MIN_KINSHIP, high=self.config_agent_manager.MAX_KINSHIP + 1, size=count),
            "parental_instinct": rng.uniform(low=self.config_agent_manager.MIN_PARENTAL, high=self.config_agent_manager.MAX_PARENTAL + 1, size=count),
            "hostility": rng.uniform(low=self.config_agent_manager.MIN_HOSTILITY, high=self.config_agent_manager.MAX_HOSTILITY + 1, size=count),
            "fight_flight_bias": rng.uniform(low=self.config_agent_manager.MIN_FIGHT_FLIGHT, high=self.config_agent_manager.MAX_FIGHT_FLIGHT + 1, size=count),

            # Metabolic States.
            "age": np.zeros(shape=count, dtype=np.uint8),
            "is_infected": np.full(shape=count, fill_value=False, dtype=pl.Boolean),
            "is_bleeding": np.full(shape=count, fill_value=False, dtype=pl.Boolean),
            "is_sleeping": np.full(shape=count, fill_value=False, dtype=pl.Boolean),
            "is_pregnant": np.full(shape=count, fill_value=False, dtype=pl.Boolean),
            "is_hibernating": np.full(shape=count, fill_value=False, dtype=pl.Boolean),
            "metabolism_modifier": np.ones(shape=count, dtype=pl.Float32),
            "health_cost": np.ones(shape=count, dtype=pl.Float32),

            # Timers & Counters.
            "hibernation_timer": np.zeros(shape=count, dtype=pl.UInt8),
            "gestation_timer": np.zeros(shape=count, dtype=pl.UInt8),
            "waste_accumulated": np.zeros(shape=count, dtype=pl.UInt8),

            "valid_move": np.full(shape=count, fill_value=False, dtype=pl.Boolean)
        }

        # 3. Creates the DataFrame.
        new_agents_df = DataFrame(data=agent_data)

        # 4. Creates columns for the attributes, that have starting values.
        new_agents_df = new_agents_df.with_columns(
            (pl.col("max_health").alias("health")), # Gets the reference to the column.
            (pl.col("max_energy") * self.config_agent_manager.BIRTH_ENERGY_FACTOR).alias("energy"),  # Name of the added attribute.
            (pl.col("resistance").alias("effective_resistance")),
            (pl.col("base_energy_burn_rate").alias("total_energy_burn_rate"))
        )

        # 5. Adds derived color columns.
        new_agents_df = new_agents_df.with_columns(
            (pl.col("meat_digestion_efficiency") * 255).cast(pl.UInt8).alias("color_r"),
            (pl.col("plant_digestion_efficiency") * 255).cast(pl.UInt8).alias("color_g"),
            (pl.col("size") * 85).cast(pl.UInt8).alias("color_b") # (Size 1, 2, 3 -> 85, 170, 255).
        )

        # 6. Handles the placement in the agent matrix.
        # Finds the flat indices of zero elements.
        zero_indices_flat: NDArray = np.flatnonzero(a=(self.agent_matrix == 0))

        # Checks whether there are enough available spots.
        if count > len(zero_indices_flat):
            raise ValueError(
                f"Can't create {count} agents. Only {len(zero_indices_flat)} empty spots are available!"
            )

        # Randomly chooses from these indices.
        random_indices_flat: NDArray = np.random.choice(
            a = zero_indices_flat,
            size = count,
            replace = False
        )

        # Updates the agent matrix.
        np.put(
            a = self.agent_matrix,
            ind = random_indices_flat,
            v = self.config_agent_manager.AGENT_MATRIX_ID
        )

        # Updates the agent color matrix.
        np.put(
            a = self.agent_color_matrix,
            ind = random_indices_flat,
            v = (pl.col("color_r"), pl.col("color_g"), pl.col("color_b"))
        )

        # Add position columns to the DataFrame.
        new_agents_df = new_agents_df.with_columns(
            (random_indices_flat % self.simulation_size)
            .alias("x_pos"), # No need for 'lit' when the source is already an array.
            (random_indices_flat // self.simulation_size)
            .alias("y_pos")
            (random_indices_flat % self.simulation_size)
            .alias("new_x_pos"),
            (random_indices_flat // self.simulation_size)
            .alias("new_y_pos")
        )

        # 7. Updates the agent DataFrame.
        self.agents_df = pl.concat([self.agents_df, new_agents_df])

    def _move_agents(
            self,
            old_df: DataFrame,
            direction_index: int # (0: Up, 1: Right, 2: Down, 3: Left).
    ) -> tuple[NDArray, DataFrame]:
        # 1. Calculates the target based on the direction.
        dx, dy = self.config_agent_manager.MOVEMENT_DIRECTIONS[direction_index]

        new_df: DataFrame = old_df.with_columns(
            (pl.col("x_pos") + dx).alias("new_x_pos"),
            (pl.col("y_pos") + dy).alias("new_y_pos")
        )

        # 2. Checks for out of bound and updates the columns.
        new_df = new_df.with_columns(
            (
                (pl.col("new_x_pos") >= 0) &
                (pl.col("new_x_pos") < self.simulation_size) &
                (pl.col("new_y_pos") >= 0) & 
                (pl.col("new_y_pos") < self.simulation_size)
            ).alias("valid_move")
        )

        # 3. Checks for colision.
        # Extract the polars columns as numpy arrays.
        potential_y: NDArray = new_df["new_y_pos"].to_numpy(dtype=np.int16) # For safe map size.
        potential_x: NDArray = new_df["new_x_pos"].to_numpy(dtype=np.int16) 

        # Clips the coordinates to safe range (0 to size-1).
        safe_y: NDArray = np.clip(potential_y, 0, self.simulation_size - 1)
        safe_x: NDArray = np.clip(potential_x, 0, self.simulation_size - 1)

        # Checks the matrix using the safe coordinates.
        is_empty_spot: NDArray = (self.agent_matrix[safe_y, safe_x] == self.config_agent_manager.EMPTY_MATRIX_ID)

        # 4. Updates the valid moves.
        new_df = new_df.with_columns(
            (pl.col("valid_move") & is_empty_spot).alias("valid_move")
        )

        # 5. Deletes the old position and updates the new.
        # Extract the polar columns as numpy arrays.
        old_pos_y: NDArray = new_df["y_pos"].to_numpy(dtype=np.uint8)
        old_pos_x: NDArray = new_df["x_pos"].to_numpy(dtype=np.uint8)

        color_r: NDArray = new_df["color_r"].to_numpy(dtype=np.uint8)
        color_g: NDArray = new_df["color_g"].to_numpy(dtype=np.uint8)
        color_b: NDArray = new_df["color_b"].to_numpy(dtype=np.uint8)

        valid_move: NDArray = new_df["valid_move"].to_numpy(dtype=np.bool_)

        # Deletes the old positions.
        self.agent_matrix[old_pos_y, old_pos_x] = self.config_agent_manager.EMPTY_MATRIX_ID
        self.agent_color_matrix[old_pos_y, old_pos_x, :] = self.config_agent_manager.EMPTY_MATRIX_ID

        # Updates the new columns.
        new_df = new_df.with_columns(
            pl.when(pl.col("valid_move"))
            .then(
                pl.col("new_x_pos").alias("x_pos"),
            )
            .otherwise(
                pl.col("x_pos").alias("x_pos"),
            )
        )

        new_df = new_df.with_columns(
            pl.when(pl.col("valid_move"))
            .then(
                pl.col("new_y_pos").alias("y_pos")
            )
            .otherwise(
                pl.col("y_pos").alias("y_pos")
            )
        )

        # Extracts the newly updated y- and x-positions.
        collision_updated_y_pos: NDArray = new_df["y_pos"].to_numpy(dtype=np.uint8)
        collision_updated_x_pos: NDArray = new_df["x_pos"].to_numpy(dtype=np.uint8)

        # Updates the matrices.
        self.agent_matrix[collision_updated_y_pos, collision_updated_x_pos] = self.config_agent_manager.AGENT_MATRIX_ID
        self.agent_color_matrix[collision_updated_y_pos, collision_updated_x_pos, :] = np.stack([color_r, color_g, color_b], axis=1) # (1000, 3).

        return (valid_move, new_df)

    def update_agents(
            self,
            map_temperature: int
    ) -> None:
        df: DataFrame = self.agents_df
        cfg: ConfigAgentManager = self.config_agent_manager

        # 1. Cheks whether the agent dies.
        df = df.filter((pl.col("energy") > 0) & (pl.col("health") > 0))

        # 2. Updates the agents age.
        df = df.with_columns(
            (pl.col("age") + 1)
            .alias("age")
        )

        # 3. Calculates the effective resistance.
        df = df.with_columns(
            pl.when((pl.col("age")) > (pl.col("max_age") // 2)) # If the age threshold is met.
            .then((1.0 - ((pl.col("age") - pl.col("max_age") // 2) / (pl.col("max_age") - pl.col("max_age") // 2)) ** 2).clip(lower_bound=0.1))
            .otherwise(1.0)
            .alias("effective_resistance")
        )

        # 4. Processes the metabolism.
        # Calculates the metabolism modifier.
        df = df.with_columns(
            (
                pl.lit(1.0) # Starts with a base metabolism multiplier of 1.0.
                * pl.when(pl.col("is_infected"))
                .then(cfg.METABOLISM_INFECTED_MULT)
                .otherwise(1.0)
                * pl.when(pl.col("is_bleeding"))
                .then(cfg.METABOLISM_BLEEDING_MULT)
                .otherwise(1.0)
                * pl.when(pl.col("is_sleeping"))
                .then(cfg.METABOLISM_SLEEPING_MULT)
                .otherwise(1.0)
                * pl.when(pl.col("is_pregnant"))
                .then(cfg.METABOLISM_PREGNANT_MULT)
                .otherwise(1.0)
                * pl.when(pl.col("is_hibernating"))
                .then(cfg.METABOLISM_HIBERNATING_MULT)
                .otherwise(1.0)
            )
            .alias("metabolism_modifier")
        )

        # Calculates the total burn rate depending on base burn rate, metabolism modifier, size and temperature.
        df = df.with_columns(
            (pl.col("base_energy_burn_rate") * pl.col("metabolism_modifier") * pl.col("size")) + ((map_temperature - pl.col("optimal_temperature").abs()) * cfg.METABOLISM_TEMP_HARSHNESS * (pl.lit(1.0) - pl.col("effective_resistance")))
            .alias("total_energy_burn_rate")
        )

        # Deducts the calculated total burn rate from current energy.
        df = df.with_columns(
            (pl.col("energy") - pl.col("total_energy_burn_rate"))
            .alias("energy")
        )

        # 5. Handles the disease, bleeding, gestation and waste accumulation states.
        # Calculates the health cost.
        df = df.with_columns(
            (
                pl.lit(0) # Starts with base health cost of 0.
                + pl.when(pl.col("is_infected"))
                .then(cfg.DISEASE_HEALTH_COST)
                .otherwise(0)
                + pl.when(pl.col("is_bleeding"))
                .then(cfg.BLEEDING_HEALTH_COST)
                .otherwise(0)
            )
            .alias("health_cost")
        )

        # Deducts the health cost from the current health.
        df = df.with_columns(
            (pl.col("health") - pl.col("health_cost"))
            .alias("health")
        )

        # Updates the gestation timer and give birth logic.
        df = df.with_columns(
            pl.when(pl.col("is_pregnant"))
            .then(pl.col("gestation_timer") + 1)
            .otherwise(pl.col("gestation_timer"))
        )

        df = df.with_columns(
            pl.when((pl.col("gestation_timer")) == (cfg.GESTATION_TIME))
            .then() #TODO Add birth logic.
        )

        # Handles the waste.
        df = df.with_columns(
            #TODO Identify the agents that need to drop waste, drop the waste and reset the waste accumulated.
        )

        # 6. Moves the agents.
