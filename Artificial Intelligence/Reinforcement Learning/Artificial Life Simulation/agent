# agent.py

#! Custom TODO notes:
#TODO AD: Add docstring.
#TODO ATH: Add type hint.
#TODO CTH: Check type hint.
#TODO FTH: Fix the hardcoding.
#TODO HPE: Handle possible error.
#TODO AC: Add comment.
#TODO AIC: Add input control.
#TODO ACV: Add constant variable.
#TODO WOO: Work on organising.

#! PW: Possibly wrong.

from typing import Tuple

import numpy as np
import polars as pl
from polars import DataFrame

from dataclasses import dataclass
from numpy.typing import NDArray

from dataclasses import dataclass
from typing import Tuple

# Type alias for clarity
MoveDirection = Tuple[int, int]

@dataclass(frozen=True)
class ConfigAgentManager:
    """
    Configuration for the Agent Manager.
    Variables are grouped logically by function.
    """

    # 1. SIMULATION & MATRIX CONSTANTS
    EMPTY_MATRIX_ID: int = 0
    AGENT_MATRIX_ID: int = 1
    # Order: Up, Right, Down, Left
    MOVEMENT_DIRECTIONS: Tuple[MoveDirection, MoveDirection, MoveDirection, MoveDirection] = (
        (0, -1), (1, 0), (0, 1), (-1, 0)
    )

    # 2. PHYSICAL GENETICS
    MIN_SIZE: int = 1
    MAX_SIZE: int = 3
    MIN_AGE: int = 50
    MAX_AGE: int = 250
    MIN_HEALTH: int = 50
    MAX_HEALTH: int = 250
    MIN_ENERGY: int = 50
    MAX_ENERGY: int = 250
    MIN_TEMP: int = 0
    MAX_TEMP: int = 50
    
    MIN_ENERGY_BURN: float = 0.1
    MAX_ENERGY_BURN: float = 1.0
    MIN_RESISTANCE: float = 0.1
    MAX_RESISTANCE: float = 1.0

    # 3. SURVIVAL GENETICS (Ranges & Chances)
    MIN_CHRONOTYPE: float = 0.1
    MAX_CHRONOTYPE: float = 1.0
    MIN_PLANT_DIGEST: float = 0.1
    MAX_PLANT_DIGEST: float = 1.0
    MIN_MEAT_DIGEST: float = 0.1
    MAX_MEAT_DIGEST: float = 1.0
    
    VENOM_CHANCE: float = 0.1
    MIMICRY_CHANCE: float = 0.1

    # 4. BEHAVIORAL GENETICS (Ranges)
    MIN_KINSHIP: float = 0.1
    MAX_KINSHIP: float = 1.0
    MIN_PARENTAL: float = 0.1
    MAX_PARENTAL: float = 1.0
    MIN_HOSTILITY: float = 0.1
    MAX_HOSTILITY: float = 1.0
    MIN_FIGHT_FLIGHT: float = 0.1
    MAX_FIGHT_FLIGHT: float = 1.0

    # 5. METABOLISM & MULTIPLIERS
    BIRTH_ENERGY_FACTOR: float = 0.5
    METABOLISM_INFECTED_MULT: float = 1.25
    METABOLISM_BLEEDING_MULT: float = 1.25
    METABOLISM_SLEEPING_MULT: float = 0.2
    METABOLISM_PREGNANT_MULT: float = 1.5
    METABOLISM_HIBERNATING_MULT: float = 0.05
    METABOLISM_TEMP_HARSHNESS: float = 0.1

    # 6. COSTS & PENALTIES
    MOVE_ENERGY_COST: int = 5
    DISEASE_HEALTH_COST: int = 5
    BLEEDING_HEALTH_COST: int = 10

    # 7. TIMERS & CAPACITIES
    GESTATION_TIME: int = 250
    MAX_WASTE_CAPACITY: int = 100

    def __post_init__(self) -> None:
        """
        Validates all configuration parameters immediately after initialization.
        Checks match the order of declaration.
        """
        
        # 1. SIMULATION & MATRIX CONSTANTS Validation 
        if not isinstance(self.EMPTY_MATRIX_ID, int) or not isinstance(self.AGENT_MATRIX_ID, int):
            raise TypeError("Matrix IDs must be integers.")
        
        if self.EMPTY_MATRIX_ID == self.AGENT_MATRIX_ID:
            raise ValueError(f"EMPTY_MATRIX_ID and AGENT_MATRIX_ID cannot be the same ({self.EMPTY_MATRIX_ID}).")

        if not isinstance(self.MOVEMENT_DIRECTIONS, tuple):
            raise TypeError("MOVEMENT_DIRECTIONS must be a tuple.")
        if len(self.MOVEMENT_DIRECTIONS) != 4:
            raise ValueError(f"MOVEMENT_DIRECTIONS must have 4 elements, got {len(self.MOVEMENT_DIRECTIONS)}.")
        for d in self.MOVEMENT_DIRECTIONS:
            if not isinstance(d, tuple) or len(d) != 2 or not all(isinstance(x, int) for x in d):
                raise TypeError("Each movement direction must be a tuple of 2 integers (dx, dy).")

        # 2. PHYSICAL GENETICS Validation 
        int_phys_ranges = [
            ("SIZE", self.MIN_SIZE, self.MAX_SIZE),
            ("AGE", self.MIN_AGE, self.MAX_AGE),
            ("HEALTH", self.MIN_HEALTH, self.MAX_HEALTH),
            ("ENERGY", self.MIN_ENERGY, self.MAX_ENERGY),
            ("TEMP", self.MIN_TEMP, self.MAX_TEMP),
        ]
        for name, min_val, max_val in int_phys_ranges:
            if not isinstance(min_val, int) or not isinstance(max_val, int):
                raise TypeError(f"MIN_{name} and MAX_{name} must be integers.")
            if min_val < 0:
                raise ValueError(f"MIN_{name} must be non-negative.")
            if max_val < min_val:
                raise ValueError(f"MAX_{name} ({max_val}) cannot be smaller than MIN_{name} ({min_val}).")

        float_phys_ranges = [
            ("ENERGY_BURN", self.MIN_ENERGY_BURN, self.MAX_ENERGY_BURN),
            ("RESISTANCE", self.MIN_RESISTANCE, self.MAX_RESISTANCE),
        ]
        for name, min_val, max_val in float_phys_ranges:
            if not isinstance(min_val, (float, int)) or not isinstance(max_val, (float, int)):
                raise TypeError(f"MIN_{name} and MAX_{name} must be numbers.")
            if min_val < 0:
                raise ValueError(f"MIN_{name} must be non-negative.")
            if max_val < min_val:
                raise ValueError(f"MAX_{name} ({max_val}) cannot be smaller than MIN_{name} ({min_val}).")

        #  3. SURVIVAL GENETICS Validation 
        float_surv_ranges = [
            ("CHRONOTYPE", self.MIN_CHRONOTYPE, self.MAX_CHRONOTYPE),
            ("PLANT_DIGEST", self.MIN_PLANT_DIGEST, self.MAX_PLANT_DIGEST),
            ("MEAT_DIGEST", self.MIN_MEAT_DIGEST, self.MAX_MEAT_DIGEST),
        ]
        for name, min_val, max_val in float_surv_ranges:
            if not isinstance(min_val, (float, int)) or not isinstance(max_val, (float, int)):
                raise TypeError(f"MIN_{name} and MAX_{name} must be numbers.")
            if min_val < 0:
                raise ValueError(f"MIN_{name} must be non-negative.")
            if max_val < min_val:
                raise ValueError(f"MAX_{name} ({max_val}) cannot be smaller than MIN_{name} ({min_val}).")

        probs = [("VENOM_CHANCE", self.VENOM_CHANCE), ("MIMICRY_CHANCE", self.MIMICRY_CHANCE)]
        for name, val in probs:
            if not isinstance(val, (float, int)):
                raise TypeError(f"{name} must be a number.")
            if not (0.0 <= val <= 1.0):
                raise ValueError(f"{name} must be between 0.0 and 1.0.")

        #  4. BEHAVIORAL GENETICS Validation 
        float_behav_ranges = [
            ("KINSHIP", self.MIN_KINSHIP, self.MAX_KINSHIP),
            ("PARENTAL", self.MIN_PARENTAL, self.MAX_PARENTAL),
            ("HOSTILITY", self.MIN_HOSTILITY, self.MAX_HOSTILITY),
            ("FIGHT_FLIGHT", self.MIN_FIGHT_FLIGHT, self.MAX_FIGHT_FLIGHT),
        ]
        for name, min_val, max_val in float_behav_ranges:
            if not isinstance(min_val, (float, int)) or not isinstance(max_val, (float, int)):
                raise TypeError(f"MIN_{name} and MAX_{name} must be numbers.")
            if min_val < 0:
                raise ValueError(f"MIN_{name} must be non-negative.")
            if max_val < min_val:
                raise ValueError(f"MAX_{name} ({max_val}) cannot be smaller than MIN_{name} ({min_val}).")

        #  5. METABOLISM & MULTIPLIERS Validation 
        multipliers = [
            ("BIRTH_ENERGY_FACTOR", self.BIRTH_ENERGY_FACTOR),
            ("METABOLISM_INFECTED_MULT", self.METABOLISM_INFECTED_MULT),
            ("METABOLISM_BLEEDING_MULT", self.METABOLISM_BLEEDING_MULT),
            ("METABOLISM_SLEEPING_MULT", self.METABOLISM_SLEEPING_MULT),
            ("METABOLISM_PREGNANT_MULT", self.METABOLISM_PREGNANT_MULT),
            ("METABOLISM_HIBERNATING_MULT", self.METABOLISM_HIBERNATING_MULT),
            ("METABOLISM_TEMP_HARSHNESS", self.METABOLISM_TEMP_HARSHNESS),
        ]
        for name, val in multipliers:
            if not isinstance(val, (float, int)):
                raise TypeError(f"{name} must be a number.")
            if val < 0:
                raise ValueError(f"{name} must be non-negative.")

        #  6. COSTS & PENALTIES Validation 
        costs = [
            ("MOVE_ENERGY_COST", self.MOVE_ENERGY_COST),
            ("DISEASE_HEALTH_COST", self.DISEASE_HEALTH_COST),
            ("BLEEDING_HEALTH_COST", self.BLEEDING_HEALTH_COST),
        ]
        for name, val in costs:
            if not isinstance(val, int):
                raise TypeError(f"{name} must be an integer.")
            if val < 0:
                raise ValueError(f"{name} must be non-negative.")

        #  7. TIMERS & CAPACITIES Validation 
        timers = [
            ("GESTATION_TIME", self.GESTATION_TIME),
            ("MAX_WASTE_CAPACITY", self.MAX_WASTE_CAPACITY),
        ]
        for name, val in timers:
            if not isinstance(val, int):
                raise TypeError(f"{name} must be an integer.")
            if val < 0:
                raise ValueError(f"{name} must be non-negative.")

class AgentManager:

    def __init__(
            self,
            config_agent_manager: ConfigAgentManager,
            simulation_size: int
    ) -> None:
        # 1. Defines input parameters.
        self.config_agent_manager: ConfigAgentManager = config_agent_manager
        self.simulation_size: int = simulation_size

        # 2. Creates agent matrix.
        self.agent_matrix: NDArray = np.zeros(
            shape = (self.simulation_size, self.simulation_size),
            dtype = np.uint8
        )

        # 3. Creates a agent DataFrame.
        self.agents_df: DataFrame = self._create_empty_agent_df()

    def _create_empty_agent_df(self) -> DataFrame:   
            agent_df_schema: dict = {
                # Identity.
                "clan_id": pl.UInt8,
                "sex": pl.UInt8,
                
                # Physical Genetics.
                "size": pl.UInt8,
                "max_age": pl.UInt8,
                "max_health": pl.UInt8,
                "max_energy": pl.UInt8,
                "optimal_temperature": pl.UInt8,
                "resistance": pl.Float32, # Base genetic resistance.
                
                # Metabolic Genetics.
                "base_energy_burn_rate": pl.Float32, # Use instead of Float16.
                "chronotype": pl.Float32,
                "plant_digestion_efficiency": pl.Float32,
                "meat_digestion_efficiency": pl.Float32,

                # Special Traits.
                "has_venom": pl.Boolean, 
                "has_mimicry": pl.Boolean,

                # Behavioral Genetics.
                "kinship_loyalty": pl.Float32,
                "parental_instinct": pl.Float32,
                "hostility": pl.Float32,
                "fight_flight_bias": pl.Float32,

                # Current Vitals.
                "age": pl.UInt8,
                "health": pl.Float32,
                "energy": pl.Float32,
                "waste_accumulated": pl.UInt8,

                # Calculated Rates & Modifiers.
                "total_energy_burn_rate": pl.Float32,
                "effective_resistance": pl.Float32, # Base resistance +/- modifiers.
                "metabolism_modifier": pl.Float32,
                "health_cost": pl.Float32,

                # Boolean Status Flags.
                "is_infected": pl.Boolean,
                "is_bleeding": pl.Boolean,
                "is_sleeping": pl.Boolean,
                "is_pregnant": pl.Boolean,
                "is_hibernating": pl.Boolean,

                # Timers.
                "hibernation_timer": pl.UInt8,
                "gestation_timer": pl.UInt8,

                # Positional States.
                "x_pos": pl.Int16,
                "y_pos": pl.Int16,
                "new_x_pos": pl.Int16,
                "new_y_pos": pl.Int16,
                "valid_move": pl.Boolean,

                # Visual Genetics/State.
                "color_r": pl.UInt8,
                "color_g": pl.UInt8,
                "color_b": pl.UInt8,
            }

            return pl.DataFrame(schema=agent_df_schema) # Creates a dataframe from the schema dictionary.

    def create_agents(
            self,
            count: int
    ) -> None:
        #TODO WOO: The order of the attributes in the dictionary.
        # 1. Creates a random number generator instance.
        rng = np.random.default_rng()

        # 2. Generates all random data in a single dictionary definition.
        agent_data: dict[str, NDArray] = {
            # Identity.
            "clan_id": rng.integers(low=0, high=0 + 1, size=count, dtype=np.uint8), #TODO Add Clan ID mechanism.
            "sex": rng.integers(low=0, high=2 + 1, size=count, dtype=np.uint8), #TODO ACV

            # Physical Genetics.
            "size": rng.integers(low=self.config_agent_manager.MIN_SIZE, high=self.config_agent_manager.MAX_SIZE + 1, size=count, dtype=np.uint8),
            "max_age": rng.integers(low=self.config_agent_manager.MIN_AGE, high=self.config_agent_manager.MAX_AGE + 1, size=count, dtype=np.uint8),
            "max_health": rng.integers(low=self.config_agent_manager.MIN_HEALTH, high=self.config_agent_manager.MAX_HEALTH + 1, size=count, dtype=np.uint8),
            "max_energy": rng.integers(low=self.config_agent_manager.MIN_ENERGY, high=self.config_agent_manager.MAX_ENERGY + 1, size=count, dtype=np.uint8),
            "optimal_temperature": rng.integers(low=self.config_agent_manager.MIN_TEMP, high=self.config_agent_manager.MAX_TEMP + 1, size=count, dtype=np.uint8),
            "resistance": rng.uniform(low=self.config_agent_manager.MIN_RESISTANCE, high=self.config_agent_manager.MAX_RESISTANCE, size=count).astype(np.float32),

            # Metabolic Genetics.
            "base_energy_burn_rate": rng.uniform(low=self.config_agent_manager.MIN_ENERGY_BURN, high=self.config_agent_manager.MAX_ENERGY_BURN + 1, size=count).astype(np.float32),
            "chronotype": rng.uniform(low=self.config_agent_manager.MIN_CHRONOTYPE, high=self.config_agent_manager.MAX_CHRONOTYPE, size=count).astype(np.float32),
            "plant_digestion_efficiency": rng.uniform(low=self.config_agent_manager.MIN_PLANT_DIGEST, high=self.config_agent_manager.MAX_PLANT_DIGEST, size=count).astype(np.float32),
            "meat_digestion_efficiency": rng.uniform(low=self.config_agent_manager.MIN_MEAT_DIGEST, high=self.config_agent_manager.MAX_MEAT_DIGEST, size=count).astype(np.float32),

            # Special Traits.
            "has_venom": rng.uniform(low=0, high=1, size=count).astype(np.float32) < self.config_agent_manager.VENOM_CHANCE, # Creates a boolean array according to the condition. #TODO Check whether the dtype matches.
            "has_mimicry": rng.uniform(low=0, high=1, size=count).astype(np.float32) < self.config_agent_manager.MIMICRY_CHANCE,

            # Behavioral Genetics.
            "kinship_loyalty": rng.uniform(low=self.config_agent_manager.MIN_KINSHIP, high=self.config_agent_manager.MAX_KINSHIP, size=count).astype(np.float32),
            "parental_instinct": rng.uniform(low=self.config_agent_manager.MIN_PARENTAL, high=self.config_agent_manager.MAX_PARENTAL, size=count).astype(np.float32),
            "hostility": rng.uniform(low=self.config_agent_manager.MIN_HOSTILITY, high=self.config_agent_manager.MAX_HOSTILITY, size=count).astype(np.float32),
            "fight_flight_bias": rng.uniform(low=self.config_agent_manager.MIN_FIGHT_FLIGHT, high=self.config_agent_manager.MAX_FIGHT_FLIGHT, size=count).astype(np.float32),

            # Current Vitals.
            "age": np.zeros(shape=count, dtype=np.uint8),
            "waste_accumulated": np.zeros(shape=count, dtype=np.uint8),
            
            # Calculated Rates & Modifiers.
            "metabolism_modifier": np.ones(shape=count, dtype=np.float32),
            "health_cost": np.ones(shape=count, dtype=np.float32),

            # Boolean Status Flags.
            "is_infected": np.full(shape=count, fill_value=False, dtype=np.bool_),
            "is_bleeding": np.full(shape=count, fill_value=False, dtype=np.bool_),
            "is_sleeping": np.full(shape=count, fill_value=False, dtype=np.bool_),
            "is_pregnant": np.full(shape=count, fill_value=False, dtype=np.bool_),
            "is_hibernating": np.full(shape=count, fill_value=False, dtype=np.bool_),

            # Timers.
            "hibernation_timer": np.zeros(shape=count, dtype=np.uint8),
            "gestation_timer": np.zeros(shape=count, dtype=np.uint8),

            # Positional States.
            "valid_move": np.full(shape=count, fill_value=False, dtype=np.bool_)
        }

        # 3. Creates the DataFrame.
        new_agents_df = DataFrame(data=agent_data)

        # 4. Creates columns for the attributes, that have starting values.
        new_agents_df = new_agents_df.with_columns(
            (pl.col("max_health").cast(pl.Float32).alias("health")), # Gets the reference to the column.
            (pl.col("max_energy") * self.config_agent_manager.BIRTH_ENERGY_FACTOR).cast(pl.Float32).alias("energy"),  # Name of the added attribute.
            (pl.col("resistance").cast(pl.Float32).alias("effective_resistance")),
            (pl.col("base_energy_burn_rate").cast(pl.Float32).alias("total_energy_burn_rate"))
        )

        # 5. Adds derived color columns.
        new_agents_df = new_agents_df.with_columns(
            (pl.col("meat_digestion_efficiency") * 255).cast(pl.UInt8).alias("color_r"),
            (pl.col("plant_digestion_efficiency") * 255).cast(pl.UInt8).alias("color_g"),
            (pl.col("size") * 85).cast(pl.UInt8).alias("color_b") # (Size 1, 2, 3 -> 85, 170, 255).
        )

        # 6. Handles the placement in the agent matrix.
        # Finds the flat indices of zero elements.
        zero_indices_flat: NDArray = np.flatnonzero(a=(self.agent_matrix == 0))

        # Checks whether there are enough available spots.
        if count > len(zero_indices_flat):
            raise ValueError(
                f"Can't create {count} agents. Only {len(zero_indices_flat)} empty spots are available!"
            )

        # Randomly chooses from these indices.
        random_indices_flat: NDArray = np.random.choice(
            a = zero_indices_flat,
            size = count,
            replace = False
        )

        # Updates the agent matrix.
        np.put(
            a = self.agent_matrix,
            ind = random_indices_flat,
            v = self.config_agent_manager.AGENT_MATRIX_ID
        )

        # Adds position columns to the DataFrame.
        new_agents_df = new_agents_df.with_columns(
            pl.lit(random_indices_flat % self.simulation_size).cast(pl.Int16).alias("x_pos"), # 'lit' converts an array into polars column.
            pl.lit(random_indices_flat // self.simulation_size).cast(pl.Int16).alias("y_pos"),
            pl.lit(random_indices_flat % self.simulation_size).cast(pl.Int16).alias("new_x_pos"),
            pl.lit(random_indices_flat // self.simulation_size).cast(pl.Int16).alias("new_y_pos")
        )

        # 7. Updates the agent DataFrame.
        # Forces the new data frame to have the same column order as the schema.
        new_agents_df = new_agents_df.select(self.agents_df.columns)

        # Concates them together.
        self.agents_df = pl.concat([self.agents_df, new_agents_df])

    def _process_metabolism(
            self,
            old_df: DataFrame,
            map_temperature: int
    ) -> DataFrame:
        cfg: ConfigAgentManager = self.config_agent_manager

        # 1. Calculates the metabolism modifier.
        new_df = old_df.with_columns(
            (
                pl.lit(1.0) # Starts with a base metabolism multiplier of 1.0.
                * pl.when(pl.col("is_infected"))
                .then(cfg.METABOLISM_INFECTED_MULT)
                .otherwise(1.0)
                * pl.when(pl.col("is_bleeding"))
                .then(cfg.METABOLISM_BLEEDING_MULT)
                .otherwise(1.0)
                * pl.when(pl.col("is_sleeping"))
                .then(cfg.METABOLISM_SLEEPING_MULT)
                .otherwise(1.0)
                * pl.when(pl.col("is_pregnant"))
                .then(cfg.METABOLISM_PREGNANT_MULT)
                .otherwise(1.0)
                * pl.when(pl.col("is_hibernating"))
                .then(cfg.METABOLISM_HIBERNATING_MULT)
                .otherwise(1.0)
            )
            .alias("metabolism_modifier")
        )

        # 2. Calculates the total burn rate depending on base burn rate, metabolism modifier, size and temperature.
        new_df = new_df.with_columns(
            (pl.col("base_energy_burn_rate") * pl.col("metabolism_modifier") * pl.col("size")) + ((map_temperature - pl.col("optimal_temperature").abs()) * cfg.METABOLISM_TEMP_HARSHNESS * (pl.lit(1.0) - pl.col("effective_resistance")))
            .alias("total_energy_burn_rate")
        )

        # 3. Deducts the calculated total burn rate from current energy.
        new_df = new_df.with_columns(
            (pl.col("energy") - pl.col("total_energy_burn_rate"))
            .alias("energy")
        )

        return new_df

    def _process_vital_states(
            self,
            old_df: DataFrame
    ) -> DataFrame:
        cfg: ConfigAgentManager = self.config_agent_manager

        # 1. Calculates the health cost.
        new_df = old_df.with_columns(
            (
                pl.lit(0) # Starts with base health cost of 0.
                + pl.when(pl.col("is_infected"))
                .then(cfg.DISEASE_HEALTH_COST)
                .otherwise(0)
                + pl.when(pl.col("is_bleeding"))
                .then(cfg.BLEEDING_HEALTH_COST)
                .otherwise(0)
            )
            .alias("health_cost")
        )

        # 2. Deducts the health cost from the current health.
        new_df = new_df.with_columns(
            (pl.col("health") - pl.col("health_cost"))
            .alias("health")
        )

        return new_df

    def _process_gestation(
            self,
            old_df: DataFrame
    ) -> DataFrame:
        cfg: ConfigAgentManager = self.config_agent_manager

        # 1. Updates the gestation timer..
        new_df = old_df.with_columns(
            pl.when(pl.col("is_pregnant"))
            .then(pl.col("gestation_timer") + 1)
            .otherwise(pl.col("gestation_timer"))
        )

        """
        # 2. If the gestation time is met, gives birth.
        new_df = new_df.with_columns(
            pl.when((pl.col("gestation_timer")) == (cfg.GESTATION_TIME))
            .then() #TODO Add birth logic.
        )
        """

        return new_df

    def _process_waste_accumulation(
            self,
            old_df: DataFrame
    ) -> DataFrame:
        # 1. Handles the waste.
        """
        df = old_df.with_columns(
            #TODO Identify the agents that need to drop waste, drop the waste and reset the waste accumulated.
        )
        """

        return old_df #! Correct it, when the method is written.

    def _move_agents(
            self,
            old_df: DataFrame,
            direction_index: int # (0: Up, 1: Right, 2: Down, 3: Left).
    ) -> tuple[NDArray, DataFrame]:
        # 1. Calculates the target based on the direction.
        dx, dy = self.config_agent_manager.MOVEMENT_DIRECTIONS[direction_index]

        new_df: DataFrame = old_df.with_columns(
            (pl.col("x_pos") + dx).alias("new_x_pos"),
            (pl.col("y_pos") + dy).alias("new_y_pos")
        )

        # 2. Checks for out of bound and updates the columns.
        new_df = new_df.with_columns(
            (
                (pl.col("new_x_pos") >= 0) &
                (pl.col("new_x_pos") < self.simulation_size) &
                (pl.col("new_y_pos") >= 0) & 
                (pl.col("new_y_pos") < self.simulation_size)
            ).alias("valid_move")
        )

        # 3. Checks for colision.
        # Extract the polars columns as numpy arrays.
        potential_y: NDArray = new_df["new_y_pos"].to_numpy().astype(dtype=np.int16) # For safe map size.
        potential_x: NDArray = new_df["new_x_pos"].to_numpy().astype(dtype=np.int16)

        # Clips the coordinates to safe range (0 to size-1).
        safe_y: NDArray = np.clip(potential_y, 0, self.simulation_size - 1)
        safe_x: NDArray = np.clip(potential_x, 0, self.simulation_size - 1)

        # Checks the matrix using the safe coordinates.
        is_empty_spot: NDArray = (self.agent_matrix[safe_y, safe_x] == self.config_agent_manager.EMPTY_MATRIX_ID)

        # 4. Updates the valid moves.
        new_df = new_df.with_columns(
            (pl.col("valid_move") & is_empty_spot).alias("valid_move")
        )

        # 5. Deletes the old position and updates the new.
        # Extract the polar columns as numpy arrays.
        old_pos_y: NDArray = new_df["y_pos"].to_numpy().astype(dtype=np.int16)
        old_pos_x: NDArray = new_df["x_pos"].to_numpy().astype(dtype=np.int16)

        valid_move: NDArray = new_df["valid_move"].to_numpy().astype(dtype=np.bool_)

        # Deletes the old positions.
        self.agent_matrix[old_pos_y, old_pos_x] = self.config_agent_manager.EMPTY_MATRIX_ID
        
        # Updates the new columns.
        new_df = new_df.with_columns(
            pl.when(pl.col("valid_move"))
            .then(
                pl.col("new_x_pos").alias("x_pos"),
            )
            .otherwise(
                pl.col("x_pos").alias("x_pos"),
            )
        )

        new_df = new_df.with_columns(
            pl.when(pl.col("valid_move"))
            .then(
                pl.col("new_y_pos").alias("y_pos")
            )
            .otherwise(
                pl.col("y_pos").alias("y_pos")
            )
        )

        # Extracts the newly updated y- and x-positions.
        collision_updated_y_pos: NDArray = new_df["y_pos"].to_numpy().astype(dtype=np.int16)
        collision_updated_x_pos: NDArray = new_df["x_pos"].to_numpy().astype(dtype=np.int16)

        # Updates the matrices.
        self.agent_matrix[collision_updated_y_pos, collision_updated_x_pos] = self.config_agent_manager.AGENT_MATRIX_ID

        return (valid_move, new_df)
    
    def agent_loop(
            self,
            map_temperature: int
    ) -> None:
        df: DataFrame = self.agents_df
        cfg: ConfigAgentManager = self.config_agent_manager

        # A. MANDATORY ACTIONS.
        # 1. Cheks whether the agent dies.
        #! df = df.filter((pl.col("energy") > 0) & (pl.col("health") > 0))

        # 2. Updates the agents age.
        df = df.with_columns(
            (pl.col("age") + 1)
            .alias("age")
        )

        # 3. Calculates the effective resistance.
        df = df.with_columns(
            pl.when((pl.col("age")) > (pl.col("max_age") // 2)) # If the age threshold is met.
            .then((1.0 - ((pl.col("age") - pl.col("max_age") // 2) / (pl.col("max_age") - pl.col("max_age") // 2)) ** 2).clip(lower_bound=0.1))
            .otherwise(1.0)
            .alias("effective_resistance")
        )

        # 4. Processes the metabolism.
        df = self._process_metabolism(
            old_df = df,
            map_temperature = map_temperature
        )

        # 5. Handles the disease, bleeding, gestation and waste accumulation states.
        # 5. Handles the vital states such as infected or bleeding.
        df = self._process_vital_states(old_df=df)

        # 6. Handles the gestation.
        df = self._process_gestation(old_df=df)

        # 7. Handles the waste accumulation.
        df = self._process_waste_accumulation(old_df=df)

        self.agents_df = df

        # B. TAKEN ACTIONS.
        # 1. Moves the agents.
        #! TESTING
        direction_index: int = np.random.randint(0, 4)
        valid_move, df = self._move_agents(
            old_df = df,
            direction_index = direction_index
        )

        self.agents_df = df

    def get_agent_state(self) -> DataFrame:
        return self.agents_df
