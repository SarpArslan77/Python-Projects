# agent.py

#! Custom TODO notes:
#TODO AD: Add docstring.
#TODO ATH: Add type hint.
#TODO CTH: Check type hint.
#TODO FTH: Fix the hardcoding.
#TODO HPE: Handle possible error.
#TODO AC: Add comment.
#TODO AIC: Add input control.
#TODO ACV: Add constant variable.
#TODO WOO: Work on organising.

#! PW: Possibly wrong.

import numpy as np
import polars as pl
from polars import DataFrame

from dataclasses import dataclass
from numpy.typing import NDArray

# Custom type hints.
move_direction = tuple[int, int]

@dataclass(frozen=True)
class ConfigAgent:
    # Identity Genetics.
    clan_id: int
    sex: int # (0, 1, 2).

    # Physical Genetics.
    size: int #(1, 2, 3).
    max_age: int
    max_health: int
    max_energy: int
    energy_burn_rate: float
    optimal_temperature: int
    resistance: float

    # Survival Genetics.
    chronotype: float
    has_venom: bool
    has_mimicry: bool
    plant_digestion_efficiency: float
    meat_digestion_efficiency: float
    
    # Behavioral Genetics.
    kinship_loyalty: float
    parental_instinct: float
    hostility: float
    fight_flight_bias: float

    def __post_init__(self) -> None:
        pass

class Agent:
    def __init__(
            self,
            config_agent: ConfigAgent,
    ) -> None:
        # Define input parameters.
        self.config_agent: ConfigAgent = config_agent

    def _calculate_senescence(self) -> float:

        # Calculates the age threshold for the scenescence to affect.
        threshold: int = self.config_agent.max_age // 2

        if self.age > threshold:
            multiplier: float = 1.0 - ((self.age - threshold) / (self.config_agent.max_age - threshold)) ** 2

            return max(multiplier, 0.1)
    
        return 1.0 # If not, no senescene effect is seen, so the attributes stay the same.

    def _process_metabolism(
            self,
            temperature: int,
            effective_resistance: float
    ) -> None:
        cfg: ConfigAgent = self.config_agent

        # 1. Calculates the state modifier.
        metabolism_modifier: float = 1.0 # Base burn rate.

        # Applies the extra states to the base burn rate.
        if self.is_infected:
            metabolism_modifier *= cfg.METABOLISM_INFECTED_MULT
        if self.is_bleeding:
            metabolism_modifier *= cfg.METABOLISM_BLEEDING_MULT
        if self.is_sleeping:
            metabolism_modifier *= cfg.METABOLISM_SLEEPING_MULT
        if self.is_pregnant:
            metabolism_modifier *= cfg.METABOLISM_PREGNANCY_MULT
        if self.is_hibernating:
            metabolism_modifier *=  cfg.METABOLISM_HIBERNATING_MULT

        # 2. Calculates the termal state modifier.
        temp_diff: int = abs(temperature - cfg.optimal_temperature)

        thermal_metabolism_modifier: float = ((temp_diff * cfg.METABOLISM_TEMP_HARSHNESS) * (1.0 - effective_resistance))

        # 3. Calculates the total burn rate depending on base burn rate, size, state and temperature.
        total_burn_rate: float = (cfg.energy_burn_rate * cfg.size * metabolism_modifier) + thermal_metabolism_modifier
        
        self.energy -= total_burn_rate

    def _handle_disease(
            self,
            effective_resistance: float
    ) -> None:
        # 1. Calculates health and energy costs.
        health_cost: float = self.config_agent.DISEASE_HEALTH_COST * (1.0 - effective_resistance)
        energy_cost: float = self.config_agent.DISEASE_ENERGY_COST * (1.0 - effective_resistance)

        # 2. Deducts the costs.
        self.health -= health_cost
        self.energy -= energy_cost

        # 3. Handles the transmission logic.
        pass

    def _handle_bleeding(
            self,
            effective_resistance: float
    ) -> None:
        # 1. Calculates health and energy costs.
        health_cost: float = self.config_agent.BLEEDING_HEALTH_COST * (1.0 - effective_resistance)
        energy_cost: float = self.config_agent.BLEEDING_ENERGY_COST * (1.0 - effective_resistance)

        # 2. Deducts the costs.
        self.health -= health_cost
        self.energy -= energy_cost
        
    def _give_birth(self) -> None:
        pass #TODO Give birth.

    def _handle_waste(self) -> None:
        pass #TODO Handles waste based on eaten food.

    def _move(
            self,
            direction_index: int, # (0 = Up, 1 = Right, 2 = Down, 3 = Left).
            simulation_size: int,
            agent_matrix: NDArray,
            agent_color_matrix: NDArray
    ) -> tuple[bool, NDArray|None, NDArray|None]:
        # 1. Calculates the target based on the direction.
        x, y = self.x, self.y

        dx, dy = self.config_agent.MOVEMENT_DIRECTIONS[direction_index]

        # 2. Checks out of bound.
        new_x, new_y = x + dx, y + dy
        
        if not(0 <= new_x < simulation_size) or not(0 <= new_y < simulation_size):
            return (False, None)

        # 3. Checks collision. 
        if agent_matrix[new_y, new_x]:
            #TODO Implement the agent trampling logic here.
            return (False, None)
        
        # 4. Deletes the old position and updates the new position.
        agent_matrix[y, x] = self.config_agent.EMPTY_MATRIX_ID
        agent_color_matrix[y, x] = self.config_agent.EMPTY_MATRIX_ID

        agent_matrix[new_y, new_x] = self.config_agent.AGENT_MATRIX_ID
        agent_color_matrix[new_y, new_x] = self.color
        self.x, self.y = new_x, new_y
        
        # 5. Deducts energy.
        self.energy -= self.config_agent.MOVE_ENERGY_COST

        # 6. Return the validation of move for Reinforcement Learning and the new matrix to update in visualization.
        return (True, agent_matrix) 
    
    def _eat(
            self,
            resource_matrix: NDArray
    ) -> tuple[bool, NDArray | None]:
        pass
    
    def agent_loop(
            self,
            temperature: int
    ) -> None:
        # A. METABOLISM ACTIONS.
        # 1. Check whether the agent dies.
        if (self.energy < 0) or (self.health < 0):
            pass #TODO DIE (deletes from the dictionary).

        # 2. Updates the agents age.
        self.age += 1

        # 3. Calculates the senescence multiplier and upon that effective resistance.
        senescence_multiplier: float = self._calculate_senescence()

        effective_resistance: float = self.config_agent.resistance * senescence_multiplier
        
        # 4. Processes the metabolism.
        self._process_metabolism(
            temperature = temperature,
            effective_resistance = effective_resistance
        )

        # 5. Handles the disease state.
        if self.is_infected:
            self._handle_disease(effective_resistance = effective_resistance)

        # 6. Handles the bleeding state.
        if self.is_bleeding:
            self._handle_bleeding(effective_resistance = effective_resistance)

        # 7. Updates the gestation.
        if self.is_pregnant:
            self.gestation_timer += 1

            if self.gestation_timer == self.config_agent.GESTATION_TIME:
                self._give_birth()
        
        # 8. Handles the waste.
        self._handle_waste()

        # B. PHYSICAL ACTIONS.

@dataclass(frozen=True)
class ConfigAgentManager:
    
    #TODO WOO
    # Physical Genetics. 
    MIN_SIZE: int = 1
    MAX_SIZE: int = 3
    MIN_AGE: int = 50
    MAX_AGE: int = 250
    MIN_HEALTH: int = 50
    MAX_HEALTH: int = 250
    MIN_ENERGY: int = 50
    MAX_ENERGY: int = 250
    MIN_TEMP: int = 0
    MAX_TEMP: int = 50
    MIN_ENERGY_BURN: float = 0.1
    MAX_ENERGY_BURN: float = 1.0
    MIN_RESISTANCE: float = 0.1
    MAX_RESISTANCE: float = 1.0
    
    # Survival Genetics.
    MIN_CHRONOTYPE: float = 0.1
    MAX_CHRONOTYPE: float = 1.0
    MIN_PLANT_DIGEST: float = 0.1
    MAX_PLANT_DIGEST: float = 1.0
    MIN_MEAT_DIGEST: float = 0.1
    MAX_MEAT_DIGEST: float = 1.0
    VENOM_CHANCE: float = 0.1
    MIMICRY_CHANCE: float = 0.1

    # Behavioral Genetics.
    MIN_KINSHIP: float = 0.1
    MAX_KINSHIP: float = 1.0
    MIN_PARENTAL: float = 0.1
    MAX_PARENTAL: float = 1.0
    MIN_HOSTILITY: float = 0.1
    MAX_HOSTILITY: float = 1.0
    MIN_FIGHT_FLIGHT: float = 0.1
    MAX_FIGHT_FLIGHT: float = 1.0

    BIRTH_ENERGY_FACTOR: float = 0.5
    AGENT_MATRIX_ID: int = 1


    # Class Constants.
    METABOLISM_INFECTED_MULT: float = 1.25
    METABOLISM_BLEEDING_MULT: float = 1.25
    METABOLISM_SLEEPING_MULT: float = 0.2
    METABOLISM_PREGNANT_MULT: float = 1.5
    METABOLISM_HIBERNATING_MULT: float = 0.05
    METABOLISM_TEMP_HARSHNESS: float = 0.1

    BIRTH_ENERGY_FACTOR: float = 0.5

    DISEASE_HEALTH_COST: int = 5 #TODO Add different types of diseases.

    BLEEDING_HEALTH_COST: int = 10

    MOVE_ENERGY_COST: int = 5
    MOVEMENT_DIRECTIONS: tuple[move_direction, move_direction, move_direction, move_direction]

    EMPTY_MATRIX_ID: int = 0
    AGENT_MATRIX_ID: int = 1

    GESTATION_TIME: int = 250

    MAX_WASTE_CAPACITY: int = 0

    def __post_init__(self) -> None:
        pass

class AgentManager:

    def __init__(
            self,
            config_agent_manager: ConfigAgentManager,
            simulation_size: int
    ) -> None:
        # 1. Defines input parameters.
        self.config_agent_manager: ConfigAgentManager = config_agent_manager
        self.simulation_size: int = simulation_size

        # 2. Creates agent matrices.
        self.agent_matrix: NDArray = np.zeros(
            shape = (self.simulation_size, self.simulation_size),
            dtype = np.uint8
        )

        self.agent_color_matrix: NDArray = np.zeros(
            shape = (self.simulation_size, self.simulation_size),
            dtype = np.uint8
        )

        # 3. Creates a agent DataFrame.
        self.agents_df: DataFrame = self._create_empty_agent_df()

    def _create_empty_agent_df(self) -> DataFrame:   
        agent_df_schema: dict = {
            #TODO WOO
            # Identity Genetics.
            "sex": pl.UInt8, 
            "clan_id": pl.UInt8,

            # Physical Genetics.
            "size": pl.UInt8,
            "max_age": pl.UInt8,
            "max_health": pl.UInt8,
            "max_energy": pl.UInt8,
            "optimal_temperature": pl.UInt8,
            "base_energy_burn_rate": pl.Float32, # Use instead of Float16, since it is not natively supported by many CPUs.
            "total_energy_burn_rate": pl.Float32,
            "resistance": pl.Float32,

            # Survival Genetics.
            "chronotype": pl.Float32,
            "plant_digestion_efficiency": pl.Float32,
            "meat_digestion_efficiency": pl.Float32,
            "has_venom": pl.Boolean, 
            "has_mimicry": pl.Boolean,

            # Behavioral Genetics.
            "kinship_loyalty": pl.Float32,
            "parental_instinct": pl.Float32,
            "hostility": pl.Float32,
            "fight_flight_bias":pl.Float32,

            # Metabolic States.
            "is_infected": pl.Boolean,
            "is_bleeding": pl.Boolean,
            "is_sleeping": pl.Boolean,
            "is_pregnant": pl.Boolean,
            "is_hibernating": pl.Boolean,
            "metabolism_modifier": pl.Float32,
            "health_cost": pl.UInt8,

            # Timers & Counters.
            "hibernation_timer":pl.UInt8,
            "gestation_timer": pl.UInt8,
            "waste_accumulated": pl.UInt8,

            # Positional States.
            "x_pos": pl.UInt8,
            "y_pos": pl.UInt8,

            # Vital States.
            "age": pl.UInt8,
            "health": pl.Float32,
            "energy": pl.Float32,
            "effective_resistance": pl.Float32,

            # Derived States.
            "color_r": pl.UInt8,
            "color_g": pl.UInt8,
            "color_b": pl.UInt8,
        }

        return pl.DataFrame(schema=agent_df_schema) # Creates a DataFrame from the schema dictionary.

    def create_agents(
            self,
            count: int
    ) -> None:
        #TODO WOO: The order of the attributes in the dictionary.
        # 1. Creates a random number generator instance.
        rng = np.random.default_rng()

        # 2. Generates all random data in a single dictionary definition.
        agent_data: dict[str, NDArray] = {
            #TODO WOO
            # Identity Genetics.
            "sex": rng.integers(low=0, high=2 + 1, size=count), #TODO ACV
            "clan_id": rng.integers(low=0, high=0 + 1, size=count), #TODO Add Clan ID mechanism.

            # Physical Genetics.
            "size": rng.integers(low=self.config_agent_manager.MIN_SIZE, high=self.config_agent_manager.MAX_SIZE + 1, size=count),
            "max_age": rng.integers(low=self.config_agent_manager.MIN_AGE, high=self.config_agent_manager.MAX_AGE + 1, size=count),
            "max_health": rng.integers(low=self.config_agent_manager.MIN_HEALTH, high=self.config_agent_manager.MAX_HEALTH + 1, size=count),
            "max_energy": rng.integers(low=self.config_agent_manager.MIN_ENERGY, high=self.config_agent_manager.MAX_ENERGY + 1, size=count),
            "optimal_temperature": rng.integers(low=self.config_agent_manager.MIN_TEMP, high=self.config_agent_manager.MAX_TEMP + 1, size=count),
            "base_energy_burn_rate": rng.uniform(low=self.config_agent_manager.MIN_ENERGY_BURN, high=self.config_agent_manager.MAX_ENERGY_BURN + 1, size=count),
            "resistance": rng.uniform(low=self.config_agent_manager.MIN_RESISTANCE, high=self.config_agent_manager.MAX_RESISTANCE + 1, size=count),

            # Survival Genetics.
            "chronotype": rng.uniform(low=self.config_agent_manager.MIN_CHRONOTYPE, high=self.config_agent_manager.MAX_CHRONOTYPE + 1, size=count),
            "plant_digestion_efficiency": rng.uniform(low=self.config_agent_manager.MIN_PLANT_DIGEST, high=self.config_agent_manager.MAX_PLANT_DIGEST + 1, size=count),
            "meat_digestion_efficiency": rng.uniform(low=self.config_agent_manager.MIN_MEAT_DIGEST, high=self.config_agent_manager.MAX_MEAT_DIGEST + 1, size=count),
            "has_venom": rng.uniform(low=0, high=1, size=count) < self.config_agent_manager.VENOM_CHANCE, # Creates a boolean array according to the condition.
            "has_mimicry": rng.uniform(low=0, high=1, size=count) < self.config_agent_manager.MIMICRY_CHANCE,

            # Behavioral Genetics.
            "kinship_loyalty": rng.uniform(low=self.config_agent_manager.MIN_KINSHIP, high=self.config_agent_manager.MAX_KINSHIP + 1, size=count),
            "parental_instinct": rng.uniform(low=self.config_agent_manager.MIN_PARENTAL, high=self.config_agent_manager.MAX_PARENTAL + 1, size=count),
            "hostility": rng.uniform(low=self.config_agent_manager.MIN_HOSTILITY, high=self.config_agent_manager.MAX_HOSTILITY + 1, size=count),
            "fight_flight_bias": rng.uniform(low=self.config_agent_manager.MIN_FIGHT_FLIGHT, high=self.config_agent_manager.MAX_FIGHT_FLIGHT + 1, size=count),

            # Metabolic States.
            "age": np.zeros(shape=count, dtype=np.uint8),
            "is_infected": np.full(shape=count, fill_value=False, dtype=bool),
            "is_bleeding": np.full(shape=count, fill_value=False, dtype=bool),
            "is_sleeping": np.full(shape=count, fill_value=False, dtype=bool),
            "is_pregnant": np.full(shape=count, fill_value=False, dtype=bool),
            "is_hibernating": np.full(shape=count, fill_value=False, dtype=bool),
            "metabolism_modifier": np.ones(shape=count, dtype=pl.Float32),
            "health_cost": np.ones(shape=count, dtype=pl.Float32),

            # Timers & Counters.
            "hibernation_timer": np.zeros(shape=count, dtype=pl.UInt8),
            "gestation_timer": np.zeros(shape=count, dtype=pl.UInt8),
            "waste_accumulated": np.zeros(shape=count, dtype=pl.UInt8),
        }

        # 3. Creates the DataFrame.
        new_agents_df = DataFrame(data=agent_data)

        # 4. Creates columns for the attributes, that have starting values.
        new_agents_df = new_agents_df.with_columns(
            (pl.col("max_health").alias("health")), # Gets the reference to the column.
            (pl.col("max_energy") * self.config_agent_manager.BIRTH_ENERGY_FACTOR).alias("energy"),  # Name of the added attribute.
            (pl.col("resistance").alias("effective_resistance")),
            (pl.col("base_energy_burn_rate").alias("total_energy_burn_rate"))
        )

        # 5. Adds derived color columns.
        new_agents_df = new_agents_df.with_columns(
            (pl.col("meat_digestion_efficiency") * 255).cast(pl.UInt8).alias("color_r"),
            (pl.col("plant_digestion_efficiency") * 255).cast(pl.UInt8).alias("color_g"),
            (pl.col("size") * 85).cast(pl.UInt8).alias("color_b") # (Size 1, 2, 3 -> 85, 170, 255).
        )

        # 6. Handles the placement in the agent matrix.
        # Finds the flat indices of zero elements.
        zero_indices_flat: NDArray = np.flatnonzero(a=(self.agent_matrix == 0))

        # Checks whether there are enough available spots.
        if count > len(zero_indices_flat):
            raise ValueError(
                f"Can't create {count} agents. Only {len(zero_indices_flat)} empty spots are available!"
            )

        # Randomly chooses from these indices.
        random_indices_flat: NDArray = np.random.choice(
            a = zero_indices_flat,
            size = count,
            replace = False
        )

        # Updates the agent matrix at the choosen spots.
        np.put(
            a = self.agent_matrix,
            ind = random_indices_flat,
            v = self.config_agent_manager.AGENT_MATRIX_ID
        )

        # Add position columns to the DataFrame.
        new_agents_df = new_agents_df.with_columns(
            (random_indices_flat % self.simulation_size)
            .alias("x_pos"), # No need for 'lit' when the source is already an array.
            (random_indices_flat // self.simulation_size)
            .alias("y_pos")
        )

        # 7. Updates the agent DataFrame.
        self.agents_df = pl.concat([self.agents_df, new_agents_df])

    def update_agents(
            self,
            map_temperature: int
    ) -> None:
        df: DataFrame = self.agents_df
        cfg: ConfigAgentManager = self.config_agent_manager

        # 1. Cheks whether the agent dies.
        df = df.filter((pl.col("energy") > 0) & (pl.col("health") > 0))

        # 2. Updates the agents age.
        df = df.with_columns(
            (pl.col("age") + 1)
            .alias("age")
        )

        # 3. Calculates the effective resistance.
        df = df.with_columns(
            pl.when((pl.col("age")) > (pl.col("max_age") // 2)) # If the age threshold is met.
            .then((1.0 - ((pl.col("age") - pl.col("max_age") // 2) / (pl.col("max_age") - pl.col("max_age") // 2)) ** 2).clip(lower_bound=0.1))
            .otherwise(1.0)
            .alias("effective_resistance")
        )

        # 4. Processes the metabolism.
        # Calculates the metabolism modifier.
        df = df.with_columns(
            (
                pl.lit(1.0) # Starts with a base metabolism multiplier of 1.0.
                * pl.when(pl.col("is_infected"))
                .then(cfg.METABOLISM_INFECTED_MULT)
                .otherwise(1.0)
                * pl.when(pl.col("is_bleeding"))
                .then(cfg.METABOLISM_BLEEDING_MULT)
                .otherwise(1.0)
                * pl.when(pl.col("is_sleeping"))
                .then(cfg.METABOLISM_SLEEPING_MULT)
                .otherwise(1.0)
                * pl.when(pl.col("is_pregnant"))
                .then(cfg.METABOLISM_PREGNANT_MULT)
                .otherwise(1.0)
                * pl.when(pl.col("is_hibernating"))
                .then(cfg.METABOLISM_HIBERNATING_MULT)
                .otherwise(1.0)
            )
            .alias("metabolism_modifier")
        )

        # Calculates the total burn rate depending on base burn rate, metabolism modifier, size and temperature.
        df = df.with_columns(
            (pl.col("base_energy_burn_rate") * pl.col("metabolism_modifier") * pl.col("size")) + ((map_temperature - pl.col("optimal_temperature").abs()) * cfg.METABOLISM_TEMP_HARSHNESS * (pl.lit(1.0) - pl.col("effective_resistance")))
            .alias("total_energy_burn_rate")
        )

        # Deducts the calculated total burn rate from current energy.
        df = df.with_columns(
            (pl.col("energy") - pl.col("total_energy_burn_rate"))
            .alias("energy")
        )

        # 5. Handles the disease, bleeding, gestation and waste accumulation states.
        # Calculates the health cost.
        df = df.with_columns(
            (
                pl.lit(0) # Starts with base health cost of 0.
                + pl.when(pl.col("is_infected"))
                .then(cfg.DISEASE_HEALTH_COST)
                .otherwise(0)
                + pl.when(pl.col("is_bleeding"))
                .then(cfg.BLEEDING_HEALTH_COST)
                .otherwise(0)
            )
            .alias("health_cost")
        )

        # Deducts the health cost from the current health.
        df = df.with_columns(
            (pl.col("health") - pl.col("health_cost"))
            .alias("health")
        )

        # Updates the gestation timer and give birth logic.
        df = df.with_columns(
            pl.when(pl.col("is_pregnant"))
            .then(pl.col("gestation_timer") + 1)
            .otherwise(pl.col("gestation_timer"))
        )

        df = df.with_columns(
            pl.when((pl.col("gestation_timer")) == (cfg.GESTATION_TIME))
            .then() #TODO Add birth logic.
        )

        # Handles the waste.
        df = df.with_columns(
            #TODO Identify the agents that need to drop waste, drop the waste and reset the waste accumulated.
        )
